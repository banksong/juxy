{"name":"Juxy","body":"Juxy is a library for unit testing XSLT stylesheets from Java. It is best suited for the projects where\r\nboth Java and XSLT are used simultaneously.\r\n\r\nJuxy features include:\r\n* Ability to invoke individual xsl templates and pass them any parameters (you can either call or apply templates with and without modes).\r\n* Ability to setup stylesheet parameters and global variables.\r\n* Ability to setup current node before transformation.\r\n* Integration with JUnit (Juxy provides its own TestCase class simplifying testing with JUnit, however, JUnit is not required for writing tests, you can use any testing framework that you like).\r\n* Transparent support for document fragments returned as transformation result (result of the called template can have more than one root node, Juxy will process such cases transparently for you).\r\n* Easy result verification with sophisticated XML assertion mechanism.\r\n* Easy validation using W3C XML Schema or a number of XPath assertions (you can use either Jaxen or JAXP XPath         engine, Juxy will detect their presence automatically).\r\n* Ability to trace execution of the sylesheets instructions.\r\n* Support for custom URIResolver.\r\n* Ant task for batch verification of XSLT stylesheets.\r\n\r\n## Examples\r\n\r\nPlease refer to [javadoc](http://teamcity.jetbrains.com/repository/download/bt24/.lastPinned/doc/javadoc/index.html?guest=1) for detailed API description.\r\n\r\nYou can use Juxy alone, in conjunction with JUnit, or with any other testing framework that you like.\r\nTo become familiar with Juxy, in the first example, we will show how to use Juxy without JUnit.\r\n\r\nWe will assume here, that there is a stylesheet with a template taking a list of xml tags and transforming it to a comma separated list of strings. For example, let it be a transformation of something like:\r\n\r\n<pre>\r\n    &lt;list>\r\n        &lt;item>item 1&lt;/item>\r\n        &lt;item>item 2&lt;/item>\r\n        ...\r\n        &lt;item>item n&lt;/item>\r\n    &lt;/list>\r\n</pre>\r\n\r\nto the string: item 1, item 2, ... item n.\r\n\r\n<pre>\r\n/* First of all we must obtain a Runner instance. Runner is a class that\r\n   actually invokes transformation and returns the result. */\r\nRunner runner = RunnerFactory.newRunner();\r\n\r\n/* To setup what and how to transform we must create RunnerContext\r\n   object, which is obtained from the Runner instance. We should\r\n   provide RunnerContext with stylesheet system id (i.e. with a path\r\n   to the stylesheet we are going to test). */\r\nRunnerContext context = runner.newRunnerContext(\"stylesheet.xsl\");\r\n\r\n/* Next we set input document into the RunnerContext. */\r\ncontext.setDocument(\"\" +\r\n        \"&lt;list>\" +\r\n        \"\t&lt;item>item 1&lt;/item>\" +\r\n        \"\t&lt;item>item 2&lt;/item>\" +\r\n        \"\t&lt;item>item 3&lt;/item>\" +\r\n        \"&lt;/list>\");\r\n\r\n/* Now we are ready to start transformation. We run it by invoking\r\n   method applyTemplates() which works similar to the XSLT\r\n   instruction: &lt;xsl:apply-templates/>.\r\n   Result of the transformation is returned as a DOM Node object.\r\n   In fact this is a DOM Document object, which in this case will\r\n   contain only one TextNode node. */\r\nNode result = runner.applyTemplates();\r\n\r\n/* To retrieve text from the returned DOM Node we can create\r\n   XPath expression. We should use XPathFactory for that. */\r\nXPathExpr xpath = XPathFactory.newXPath(\"text()\");\r\n\r\n/* Now we are ready to evaluate the expression. */\r\nString resultText = xpath.toString(result);\r\n</pre>\r\n\r\nNote: DOM Document in our case actually contains not well formed XML document,\r\nwhich consists of one text node only. Usually it is impossible to create such a document,\r\nhowever Juxy applies a simple workaround for that: internally Juxy holds transformation results\r\nin a DocumentFragment node, but from the Runner you will receive a proxy object, which will behave like a Document node containing all the child nodes of the DocumentFragment node.\r\n\r\nWith JUnit it is possible to write more compact tests. For that you should extend your test cases from\r\nJuxyTestCase. Take a look how the same test looks with JUnit:\r\n\r\n<pre>\r\n/* We should extend our test case from JuxyTestCase. */\r\npublic class SampleTestCase extends JuxyTestCase {\r\n\r\n    public void testListTransformation() {\r\n    /* We should not store context in the local variable, it will be stored\r\n       automatically within the test case itself. */\r\n       newContext(\"stylesheet.xsl\");\r\n\r\n    /* To obtain current RunnerContext we can call the context() method. */\r\n       context().setDocument(\"\" +\r\n            \"&lt;list>\" +\r\n            \"\t&lt;item>item 1&lt;/item>\" +\r\n            \"\t&lt;item>item 2&lt;/item>\" +\r\n            \"\t&lt;item>item 3&lt;/item>\" +\r\n            \"&lt;/list>\");\r\n\r\n    /* We do not need to know about Runner here. We can simply invoke applyTemplates()\r\n       method. Runner will be instantiated automatically within JuxyTestCase. */\r\n       Node result = applyTemplates();\r\n\r\n    /* With JuxyTestCase verification of the result is much simpler. */\r\n       xpathAssert(\"text()\", \"item 1, item 2, item 3\").eval(result);\r\n    }\r\n\r\n}\r\n</pre>\r\n\r\nJuxy also supports an XML format for tests. For example:\r\n\r\n<pre>\r\n&lt;test name=\"MoreThanOneElementInTheList_ApplyTemplates\"&gt;\r\n  &lt;document select=\"/list\"&gt;\r\n    &lt;list&gt;\r\n       &lt;item&gt;first item&lt;/item&gt;\r\n       &lt;item&gt;second item&lt;/item&gt;\r\n       &lt;item&gt;third item&lt;/item&gt;\r\n    &lt;/list&gt;\r\n  &lt;/document&gt;\r\n  &lt;apply-templates select=\"/list\"/&gt;\r\n  &lt;assert-equals&gt;\r\n    &lt;expected&gt;first item, second item, third item&lt;/expected&gt;\r\n  &lt;/assert-equals&gt;\r\n&lt;/test&gt;\r\n</pre>\r\n\r\n\r\nMore samples are available in the Juxy [samples](https://github.com/pavelsher/juxy/tree/master/samples) directory.\r\n\r\n### How does it work?\r\n\r\nJuxy works by dynamically creating XSLT stylesheet. From that stylesheet the tested stylesheet is imported via\r\n&lt;xsl:import/> instruction, thus all its templates and variables automatically get lower priority, so we can\r\neasily redefine them.\r\n\r\nAny variables and parameters specified in the RunnerContext will be placed in the generated stylesheet. If current\r\nnode was specified, then corresponding &lt;xsl:for-each/> is added to that stylesheet.\r\n\r\nThus when call or apply templates method is invoked, Juxy generates new XSLT stylesheet (it will be generated\r\nas DOM Document), places there specified variables and parameters, and inserts template matching root node (\"/\").\r\nIn this template the required &lt;xsl:call-template/> or &lt;xsl:apply-templates/> instructions are placed.\r\nIf current node was specified then &lt;xsl:for-each/> instruction will be added as their parent. To avoid endless loop Juxy will not insert apply-templates instruction if current node was set to \"/\".\r\n\r\nBecause Juxy does not use any XSLT processor specific features it should work with any XSLT processor supporting\r\nJAXP/TRaX API. For now it is known to work with [Apache Xalan](http://xml.apache.org/xalan-j/) and\r\n[Saxon](http://saxon.sourceforge.net/\") (both Saxon 6.5.X and Saxon 8.X are supported). XSLT 2.0\r\ntemplates are also supported.\r\n\r\n## Other features\r\n\r\n### Other ways to start transformation\r\n\r\nIn the examples above we invoked the transformation by calling method Runner.applyTemplates().\r\nBut it is also possible to get the results of the transformation produced by individual templates.\r\nYou can apply individual templates by specifying XPath expression and mode, or you can call templates by their name. Refer to the Runner's Javadoc for more details.\r\n\r\nOften template requires current node to be set up. By default, it is a root node of the input document,\r\nbut you can set your own current node using method RunnerContext.setCurrentNode(XPathExpr).\r\nRunnerContext also allows you to setup global transformation parameters, global variables, parameters for the template and namespaces.\r\n\r\n### Assertions\r\n\r\nWith XPath you can apply different assertions on the transformation result. However, in most cases it is easier to compare XML fragments. You can do this with XMLComparator.assertXMLEquals(String, Node) method, for example: \r\n<pre>XMLComparator.assertXMLEquals(\"&lt;p>expected text&lt;/p>\", result);</pre>\r\n\r\nThe assertXMLEquals method will compare expected document and the result node by node. In case of any differences you will get an output similar to:\r\n\r\n<pre>\r\nDocuments differ, expected document:\r\n&lt;p>expected text&lt;/p>\r\n\r\nActual document:\r\n&lt;p>actual text&lt;/p>\r\n</pre>\r\n\r\nIf you are using JuxyTestCase, this method is available directly from this class. JuxyTestCase also provides a couple of methods allowing to normalize text, i.e. to collapse spaces and remove trailing spaces. They are useful if spaces between words are insignificant for you.\r\n\r\n### Tracing\r\n\r\nIn some situations it is hard to understand why transformation does not work as you expected. For that purposes Juxy provides you with an ability to trace execution of the XSLT instructions. You can enable or disable tracing by calling methods JuxyTestCase.enableTracing and JuxyTestCase.disableTracing correspondingly (or you can call these methods from the Runner instance). The tracing output looks like:\r\n\r\n<pre>\r\nTracing of the stylesheet file://some/path/stylesheet.xsl started\r\n2:  &lt;xsl:template match=\"/\">\r\n3:      &lt;xsl:for-each select=\"//*\">\r\n4:          &lt;xsl:value-of select=\".\">\r\n3:      &lt;xsl:for-each select=\"//*\">\r\n4:          &lt;xsl:value-of select=\".\">\r\n</pre>\r\n\r\nIn the tracing output you can see both, the line numbers and corresponding XSLT instructions.\r\nThere are limitations, and the most essential is that for now only instructions within templates and\r\ntemplate instructions itself are traced. Global variables, parameters and keys are not traced.\r\n\r\nAnother limitation is that currently tracing is supported for Saxon and Xalan only. Xalan XSLTC is not supported.\r\n\r\n### XSLT Verification\r\n\r\nStarting from version 0.7 Juxy package contains Ant task which performs syntax verification of a number of stylesheets at once. This task tries to compile every stylesheet (by creating JAXP Transformer object) and reports all errors and warnings.\r\n\r\nJuxy verifier task checks parent stylesheets only, i.e. the stylesheets which are not included or imported from any other stylesheets, because included stylesheets can use global variables and parameters defined in the parent and might not be compiled without parent. Juxy will automatically filter out all imported and included stylesheets from the specified file set.\r\n\r\nAn example of task usage:\r\n\r\n<pre>\r\n&lt;path id=\"juxy_ant.task.path\">\r\n    &lt;pathelement path=\"xalan.jar\"/>\r\n    &lt;pathelement path=\"juxy_ant.jar\"/>\r\n&lt;/path>\r\n\r\n&lt;target name=\"verify-xsl\">\r\n    &lt;taskdef resource=\"juxy_ant.properties\"\r\n             classpathref=\"juxy_ant.task.path\"/>\r\n\r\n    &lt;verifier>\r\n        &lt;fileset dir=\"xsl\">\r\n            &lt;include name=\"**/*.xsl\"/>\r\n        &lt;/fileset>\r\n    &lt;/verifier>\r\n&lt;/target>\r\n</pre>\r\n\r\nTask supports the following attributes:\r\n<table class=\"ant_attributes\" cellpadding=\"0\" cellspacing=\"0\">\r\n<tr>\r\n    <th class=\"th\">Attribute</th>\r\n    <th class=\"th\">Description</th>\r\n    <th class=\"th\">Required</th>\r\n</tr>\r\n<tr>\r\n    <td class=\"td\">dir</td>\r\n    <td class=\"td\">Directory where to search for xsl files</td>\r\n    <td class=\"td\">No, if nested &lt;fileset> specified.</td>\r\n</tr>\r\n<tr>\r\n    <td class=\"td\">includes</td>\r\n    <td class=\"td\">Comma- or space-separated list of files (may be specified using wildcard patterns) that must be included.</td>\r\n    <td class=\"td\">No</td>\r\n</tr>\r\n<tr>\r\n    <td class=\"td\">excludes</td>\r\n    <td class=\"td\">Comma- or space-separated list of files (may be specified using wildcard patterns) that must be excluded.</td>\r\n    <td class=\"td\">No</td>\r\n</tr>\r\n<tr>\r\n    <td class=\"td\">failonerror</td>\r\n    <td class=\"td\">Whether to fail on first error or not. True by default.</td>\r\n    <td class=\"td\">No</td>\r\n</tr>\r\n</table>\r\n\r\nThe following nested elements are allowed:\r\n\r\n* standard Ant &lt;fileset/>\r\n* &lt;catalog/> this element if appeared turns on XML catalogs resolution.\r\n\r\nThe &lt;catalog/> element has the following attributes:\r\n\r\n<table class=\"ant_attributes\" cellpadding=\"0\" cellspacing=\"0\">\r\n<tr>\r\n    <th class=\"th\">Attribute</th>\r\n    <th class=\"th\">Description</th>\r\n    <th class=\"th\">Required</th>\r\n</tr>\r\n<tr>\r\n    <td class=\"td\">catalogfiles</td>\r\n    <td class=\"td\">Comma separated paths to the catalog files.</td>\r\n    <td class=\"td\">Yes</td>\r\n</tr>\r\n</table>\r\n\r\n### Logging\r\n\r\nJuxy produces some log messages which might be helpful for discovering problems. For logging purposes Juxy uses Jakarta commons-logging API, so commons-logging jars must be in the classpath.\r\n\r\n## Requirements\r\n\r\nJuxy requires Java 1.4 and will not work with earlier versions. A number of required libraries depends on a version of Java you are using.\r\n\r\nFor Java 1.4 the following libraries are required:\r\n\r\n* juxy.jar</li>\r\n* [commons-logging](http://jakarta.apache.org/commons/logging/)\r\n* [Jaxen](http://jaxen.codehaus.org/)\r\n* [Xerces 2](http://xml.apache.org/xerces2-j/)\r\n* JAXP compliant XSLT engine\r\n\r\nFor Java 1.5 you should have:\r\n\r\n* juxy.jar</li>\r\n* [commons-logging](http://jakarta.apache.org/commons/logging/)\r\n* JAXP compliant XSLT engine</li>\r\n\r\nA couple of words about XML parser, XPath and XSLT engine.\r\n\r\nJuxy has been tested with [Xerces 2](http://xml.apache.org/xerces2-j/) XML parser which is included now into the Java 1.5.\r\nJuxy does not depend on any Xerces specific functionality, so it should work with other JAXP compliant XML parsers, which support SAX 2 Core, DOM Level 2 Core and Traversal and Range.\r\n\r\nFor XPath expressions Juxy supports both [Jaxen](http://jaxen.codehaus.org/) and [JAXP XPath](http://xml.apache.org/xerces2-j/javadocs/api/javax/xml/xpath/package-summary.html) (appeared in Java 1.5). Juxy will automatically detect presence of the supported engine, so if you are going to run tests under the Java 1.5 Jaxen is no longer required.\r\n\r\nAs for XSLT engine, Juxy should work with any JAXP compliant XSLT processor which supports XSLT 1.0 specification and JAXP DOMResult. Both [Xalan](http://xml.apache.org/xalan-j/) and [Saxon](http://saxon.sourceforge.net/) (6.5.X and 8.X versions) were tested and work fine with Juxy. Since version 0.7.2 Juxy also supports XSLT processor bundled with Java 1.5.\r\n\r\nThe following libraries are required for Ant verifier task:\r\n* juxy_ant.jar\r\n* JAXP compliant XSLT engine\r\n* [XML commons resolver](http://xml.apache.org/commons/) (optional)\r\n\r\nXML commons resolver.jar is required if you are going to use XML catalogs URI resolution. juxy.jar is not required for Ant task.\r\n\r\n## Download package\r\n\r\nJuxy is distributed under the terms of the Apache License 2.0.\r\n\r\nThe latest version of Juxy is 0.8. You can download it [here](http://juxy.tigris.org/servlets/ProjectDocumentList?folderID=5095&expandFolder=5095&folderID=7539).\r\n\r\nThe package includes:\r\n* [API javadoc](http://teamcity.jetbrains.com/repository/download/bt24/.lastPinned/doc/javadoc/index.html?guest=1)\r\n* juxy.jar\r\n* juxy_ant.jar\r\n* juxy_src.jar\r\n* samples\r\n* required libraries to run samples\r\n</ul>\r\n\r\nJuxy uses [TeamCity](http://www.jetbrains.com/teamcity) Continuous Integration server. The project has been setup in [TeamCity demo installation](http://teamcity.jetbrains.com/project.html?projectId=project16&tab=projectOverview&guest=1).\r\n\r\n## Whom to contact?\r\n\r\nMy name is Pavel Sher, and I am the author of this project. Support for tests in XML format was contributed by Tony Graham. \r\n\r\nPlease send your thoughts and questions to the [users mailing list](http://juxy.tigris.org/ds/viewForumSummary.do?dsForumId=3638).\r\nIf you found a bug, you can report it into the [issues mailing list](http://juxy.tigris.org/ds/viewForumSummary.do?dsForumId=3637).\r\n\r\n## Related projects\r\n\r\nHere are some related projects I do know about:\r\n* [A set of XSLT stylesheets to simplify XSLT Unit Testing](http://www.jenitennison.com/xslt/utilities/unit-testing/)\r\n* [XSLTunit](http://xsltunit.org/)\r\n* [XMLUnit - JUnit and NUnit testing for XML](http://xmlunit.sourceforge.net/)\r\n* [UTF-X - Unit Testing Framework - XSLT](http://utf-x.sourceforge.net/)\r\n\r\n\r\n","tagline":"Juxy - XSLT unit testing for Java","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}